<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="ok！~我立giaogiao">
<meta property="og:type" content="website">
<meta property="og:title" content="giao哥的档案库">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="giao哥的档案库">
<meta property="og:description" content="ok！~我立giaogiao">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="giao哥的档案库">
<meta name="twitter:description" content="ok！~我立giaogiao">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>giao哥的档案库</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">giao哥的档案库</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/人工智障录---基于电影本体和协同过滤的推荐系统是怎么giao出来的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/人工智障录---基于电影本体和协同过滤的推荐系统是怎么giao出来的/" itemprop="url">人工智障录---基于电影本体和协同过滤的推荐系统是怎么giao出来的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T13:48:00+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><h2 id="在一切开始之前。必须先熟悉数据集。"><a href="#在一切开始之前。必须先熟悉数据集。" class="headerlink" title="在一切开始之前。必须先熟悉数据集。"></a>在一切开始之前。必须先熟悉数据集。</h2><h3 id="MovieLens数据集："><a href="#MovieLens数据集：" class="headerlink" title="MovieLens数据集："></a>MovieLens数据集：</h3><h4 id="有三个文件是非常重要的"><a href="#有三个文件是非常重要的" class="headerlink" title="有三个文件是非常重要的"></a>有三个文件是非常重要的</h4><ul>
<li>u-item:这里记录了所有电影的信息。包括电影流派特征的二进制向量，部分数据是这样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">63|Santa Clause, The (1994)|01-Jan-1994||http://us.imdb.com/M/title-exact?Santa%20Clause,%20The%20(1994)|0|0|0|0|1|1|0|0|0|0|0|0|0|0|0|0|0|0|0</span><br><span class="line">64|Shawshank Redemption, The (1994)|01-Jan-1994||http://us.imdb.com/M/title-exact?Shawshank%20Redemption,%20The%20(1994)|0|0|0|0|0|0|0|0|1|0|0|0|0|0|0|0|0|0|0</span><br><span class="line">65|What&apos;s Eating Gilbert Grape (1993)|01-Jan-1993||http://us.imdb.com/M/title-exact?What&apos;s%20Eating%20Gilbert%20Grape%20(1993)|0|0|0|0|0|1|0|0|1|0|0|0|0|0|0|0|0|0|0</span><br><span class="line">66|While You Were Sleeping (1995)|01-Jan-1995||http://us.imdb.com/M/title-exact?While%20You%20Were%20Sleeping%20(1995)|0|0|0|0|0|1|0|0|0|0|0|0|0|0|1|0|0|0|0</span><br><span class="line">67|Ace Ventura: Pet Detective (1994)|01-Jan-1994||http://us.imdb.com/M/title-exact?Ace%20Ventura:%20Pet%20Detective%20(1994)|0|0|0|0|0|1|0|0|0|0|0|0|0|0|0|0|0|0|0</span><br></pre></td></tr></table></figure>
<ul>
<li>u-data:核心的数据，主要是 [用户ID 电影ID 该用户对该电影的评分 时间戳] 组成,时间戳基本没用，部分数据是这样的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">196    242	3	881250949</span><br><span class="line">186	302	3	891717742</span><br><span class="line">22	377	1	878887116</span><br><span class="line">244	51	2	880606923</span><br><span class="line">166	346	1	886397596</span><br><span class="line">298	474	4	884182806</span><br><span class="line">115	265	2	881171488</span><br></pre></td></tr></table></figure>
<ul>
<li>u-user:用户的信息数据，主要是[用户ID 年龄 性别 职业 邮编] 用来做人口统计的主要数据：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1|24|M|technician|85711</span><br><span class="line">2|53|F|other|94043</span><br><span class="line">3|23|M|writer|55106</span><br><span class="line">4|24|M|technician|43537</span><br><span class="line">5|33|F|other|15213</span><br><span class="line">6|42|M|executive|98101</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="大前提–通过u-item文件求出电影的相似度矩阵"><a href="#大前提–通过u-item文件求出电影的相似度矩阵" class="headerlink" title="大前提–通过u-item文件求出电影的相似度矩阵"></a>大前提–通过u-item文件求出电影的相似度矩阵</h1><p>##　第一步！～清洗数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str_movie = open(&quot;D:\GyDevelopData\pycharsWorkspace\spiderman\data_res\u.item&quot;,&quot;r+&quot;)</span><br><span class="line">list_matrix =[]</span><br><span class="line">for line in str_movie.readlines():</span><br><span class="line">    list_num=[]</span><br><span class="line">    matreix = line.strip(&apos;\n&apos;)</span><br><span class="line">    fields = matreix.split(&quot;|&quot;)</span><br><span class="line">    for i in range(5,fields.__len__(),1):</span><br><span class="line">        list_num.append(int(fields[i]))</span><br><span class="line">    list_matrix.append(list_num)</span><br><span class="line">np_list = np.array(list_matrix)</span><br></pre></td></tr></table></figure></p>
<p>这一步主要是把每部电影的流派特征的二进制向量洗出来存在一个由numpy生成的特征矩阵里</p>
<p>##　第二步！~通过特征矩阵来求每部电影之间的相似度矩阵</p>
<h3 id="这个矩阵是对称的，为了后续的查找"><a href="#这个矩阵是对称的，为了后续的查找" class="headerlink" title="这个矩阵是对称的，为了后续的查找"></a>这个矩阵是对称的，为了后续的查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">similarNum = np.zeros((m,m),dtype=float)</span><br><span class="line">def mo(mat,smat,n):</span><br><span class="line">   for i in range(0,n,1):</span><br><span class="line">     for j in range(i+1,n,1):</span><br><span class="line">       Q11 = 0</span><br><span class="line">       Q01 = 0</span><br><span class="line">       Q10 = 0</span><br><span class="line">       for m in range(19):</span><br><span class="line">         if mat[i,m]==mat[j,m] &amp; mat[i,m] == 1:</span><br><span class="line">            Q11 += 1</span><br><span class="line">         elif (mat[i,m] != mat[j,m]) &amp;  mat[i,m] == 1:</span><br><span class="line">            Q10 += 1</span><br><span class="line">         elif (mat[i,m] != mat[j,m]) &amp;  mat[j,m] == 1:</span><br><span class="line">            Q01 += 1</span><br><span class="line">         else :continue</span><br><span class="line">       smat[i][j] = (format(float(Q11)/float((Q11+Q01+Q10)),&apos;.2f&apos;))</span><br><span class="line">       smat[j][i] = (format(float(Q11)/float((Q11+Q01+Q10)),&apos;.2f&apos;))</span><br></pre></td></tr></table></figure>
<p>先用numpy生成了一个全是0的矩阵，然后通过计算再往里面添加数据。具体的计算方法就是老外那个语义相似度的求法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.save(&quot;D:\Desktop\g.npy&quot;,similarNum)</span><br></pre></td></tr></table></figure></p>
<p>最后把相似度矩阵存在npy文件里，这样numpy就能直接读了。速度非常快，这个矩阵就是整个推荐系统的核心所在</p>
<h1 id="开始干活！推荐算法实现"><a href="#开始干活！推荐算法实现" class="headerlink" title="开始干活！推荐算法实现"></a>开始干活！推荐算法实现</h1><h2 id="根据知网上的传统协同过滤算法的描述再综合起来再把相似度矩阵加入到其中，基本上分为这几个结构"><a href="#根据知网上的传统协同过滤算法的描述再综合起来再把相似度矩阵加入到其中，基本上分为这几个结构" class="headerlink" title="根据知网上的传统协同过滤算法的描述再综合起来再把相似度矩阵加入到其中，基本上分为这几个结构"></a>根据知网上的传统协同过滤算法的描述再综合起来再把相似度矩阵加入到其中，基本上分为这几个结构</h2><h3 id="求余弦："><a href="#求余弦：" class="headerlink" title="* 求余弦："></a>* 求余弦：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def getCosDist(user1, user2):</span><br><span class="line">    sum_x = 0.0</span><br><span class="line">    sum_y = 0.0</span><br><span class="line">    sum_xy = 0.0</span><br><span class="line">    for key1 in user1:</span><br><span class="line">        for key2 in user2:</span><br><span class="line">            if key1[0] == key2[0]:</span><br><span class="line">                sum_x += key1[1] * key1[1]</span><br><span class="line">                sum_y += key2[1] * key2[1]</span><br><span class="line">                sum_xy += key1[1] * key2[1]</span><br><span class="line">    if sum_xy == 0.0:</span><br><span class="line">        return 0</span><br><span class="line">    demo = math.sqrt(sum_x * sum_y)</span><br><span class="line">    return sum_xy / demo</span><br></pre></td></tr></table></figure>
<p>为啥要求余弦。因为余弦距离，也称为余弦相似度，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量。这个度量更注重于两个个体的近似度，不是距离和长度的度量。相对准点，要不用皮尔森求也行</p>
<h3 id="特征工程-数据的清洗和特征的提取："><a href="#特征工程-数据的清洗和特征的提取：" class="headerlink" title="* [特征工程]数据的清洗和特征的提取："></a>* [特征工程]数据的清洗和特征的提取：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def getRatingInfo(ratings):</span><br><span class="line">    rates = []</span><br><span class="line">    for line in ratings:</span><br><span class="line">        rate = line.split(&quot;\t&quot;)</span><br><span class="line">        rates.append([int(rate[0]), int(rate[1]), int(rate[2])])</span><br><span class="line">    return rates</span><br><span class="line"></span><br><span class="line">def getUserScoreDataStructure(rates):</span><br><span class="line">    userDict = &#123;&#125;</span><br><span class="line">    itemUser = &#123;&#125;</span><br><span class="line">    for k in rates:</span><br><span class="line">        user_rank = (k[1], k[2])</span><br><span class="line">        if k[0] in userDict:</span><br><span class="line">            userDict[k[0]].append(user_rank)</span><br><span class="line">        else:</span><br><span class="line">            userDict[k[0]] = [user_rank]</span><br><span class="line">        if k[1] in itemUser:</span><br><span class="line">            itemUser[k[1]].append(k[0])</span><br><span class="line">        else:</span><br><span class="line">            itemUser[k[1]] = [k[0]]</span><br><span class="line">    return userDict, itemUser</span><br></pre></td></tr></table></figure>
<h4 id="第一个方法就是单纯的清洗数据，把u-data中除了时间戳的数据都清洗出来放到一个列表里"><a href="#第一个方法就是单纯的清洗数据，把u-data中除了时间戳的数据都清洗出来放到一个列表里" class="headerlink" title="第一个方法就是单纯的清洗数据，把u-data中除了时间戳的数据都清洗出来放到一个列表里"></a>第一个方法就是单纯的清洗数据，把u-data中除了时间戳的数据都清洗出来放到一个列表里</h4><h4 id="第二个方法是在这个列表中进行特征提取，提取出userDict和itemUser，userDict的格式是-用户ID：-电影ID-评分-，。。。-就是说这个人都看过啥电影并多少评分，itemUser的格式是-电影ID-用户ID，。。。-就是这个电影都被谁看过"><a href="#第二个方法是在这个列表中进行特征提取，提取出userDict和itemUser，userDict的格式是-用户ID：-电影ID-评分-，。。。-就是说这个人都看过啥电影并多少评分，itemUser的格式是-电影ID-用户ID，。。。-就是这个电影都被谁看过" class="headerlink" title="第二个方法是在这个列表中进行特征提取，提取出userDict和itemUser，userDict的格式是[用户ID：(电影ID,评分)，。。。]就是说这个人都看过啥电影并多少评分，itemUser的格式是[电影ID:(用户ID，。。。)]就是这个电影都被谁看过"></a>第二个方法是在这个列表中进行特征提取，提取出userDict和itemUser，userDict的格式是[用户ID：(电影ID,评分)，。。。]就是说这个人都看过啥电影并多少评分，itemUser的格式是[电影ID:(用户ID，。。。)]就是这个电影都被谁看过</h4><h3 id="找邻居–求用户与用户之间的相似度："><a href="#找邻居–求用户与用户之间的相似度：" class="headerlink" title="找邻居–求用户与用户之间的相似度："></a>找邻居–求用户与用户之间的相似度：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def getnneighbor(userId, userDict, itemUser):</span><br><span class="line">    neighbors = []</span><br><span class="line">    for item in userDict[userId]:  #先按这个人看的电影找</span><br><span class="line">        for neighbor in itemUser[item[0]]:  #看谁跟他看的电影一样</span><br><span class="line">            if neighbor != userId and neighbor not in neighbors: #如果不是他自己就放在邻居列表里</span><br><span class="line">                neighbors.append(neighbor)   #邻居的列表</span><br><span class="line">    neighbors_dist = []</span><br><span class="line">    for neighbor in neighbors:</span><br><span class="line">        dist = getCosDist(userDict[userId], userDict[neighbor]) #通过这个人和他邻居对这个电影的打分来求相似度</span><br><span class="line">        neighbors_dist.append([dist, neighbor]) #存到格式为[(相似度,邻居)]的列表中</span><br><span class="line">    neighbors_dist.sort(reverse = True) #排个序</span><br><span class="line">    return neighbors_dist #返回</span><br></pre></td></tr></table></figure>
<h4 id="通过上面方法的提取，在这两个列表中通过用户与用户之间的评分的余弦值来求这两个用户的相似度，最后把这个相似度列表排个序返回。"><a href="#通过上面方法的提取，在这两个列表中通过用户与用户之间的评分的余弦值来求这两个用户的相似度，最后把这个相似度列表排个序返回。" class="headerlink" title="通过上面方法的提取，在这两个列表中通过用户与用户之间的评分的余弦值来求这两个用户的相似度，最后把这个相似度列表排个序返回。"></a>通过上面方法的提取，在这两个列表中通过用户与用户之间的评分的余弦值来求这两个用户的相似度，最后把这个相似度列表排个序返回。</h4><h3 id="解决冷启动–基于人口普查求用户的特征："><a href="#解决冷启动–基于人口普查求用户的特征：" class="headerlink" title="解决冷启动–基于人口普查求用户的特征："></a>解决冷启动–基于人口普查求用户的特征：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(threshold=&apos;nan&apos;)</span><br><span class="line">zhiY = open(&quot;D:\GyDevelopData\pycharsWorkspace\spiderman\data_res\u.user&quot;,&quot;r+&quot;)</span><br><span class="line">occup = open(&quot;D:\GyDevelopData\pycharsWorkspace\spiderman\data_res\u.occupation&quot;,&quot;r+&quot;)</span><br><span class="line">Matrix_per = np.zeros((943,4),dtype=float)</span><br><span class="line">occ =&#123;&#125;</span><br><span class="line">sex = &#123;&#125;</span><br><span class="line">h = 1</span><br><span class="line">n = 0</span><br><span class="line">for i in occup.readlines():</span><br><span class="line">    i = i.strip(&quot;\n&quot;)</span><br><span class="line">    occ[i] = h</span><br><span class="line">    h = h+1</span><br><span class="line">sex[&quot;M&quot;] = 1</span><br><span class="line">sex[&quot;F&quot;] = 0</span><br><span class="line">for str in zhiY.readlines():</span><br><span class="line">    field = str.split(&quot;|&quot;)</span><br><span class="line">    m = 0</span><br><span class="line">    if float(field[1])&lt;=18:</span><br><span class="line">        Matrix_per[n][m] = 1</span><br><span class="line">    elif float(field[1])&gt;=18 and float(field[1])&lt;=24:</span><br><span class="line">        Matrix_per[n][m] = 2</span><br><span class="line">    elif float(field[1])&gt;=25 and float(field[1])&lt;=34:</span><br><span class="line">        Matrix_per[n][m] = 3</span><br><span class="line">    elif float(field[1])&gt;=35 and float(field[1])&lt;=44:</span><br><span class="line">        Matrix_per[n][m] = 4</span><br><span class="line">    elif float(field[1])&gt;=45 and float(field[1])&lt;=54:</span><br><span class="line">        Matrix_per[n][m] = 5</span><br><span class="line">    elif float(field[1])&gt;=54:</span><br><span class="line">        Matrix_per[n][m] = 6</span><br><span class="line">    m = m+1</span><br><span class="line">    Matrix_per[n][m] = sex[field[2]]</span><br><span class="line">    m= m+1</span><br><span class="line">    Matrix_per[n][m] = occ[field[3]]</span><br><span class="line">    m = m + 1</span><br><span class="line">    gb = field[4].strip()</span><br><span class="line">    Matrix_per[n][m] = gb[0:3]</span><br><span class="line">    n = n + 1</span><br><span class="line">print max(Matrix_per[:,0])-min(Matrix_per[:,0])</span><br><span class="line">print Matrix_per</span><br></pre></td></tr></table></figure>
<h4 id="这个方法我是实现自《基于用户人口统计特征与信任机制的协同推荐》里面的描述"><a href="#这个方法我是实现自《基于用户人口统计特征与信任机制的协同推荐》里面的描述" class="headerlink" title="这个方法我是实现自《基于用户人口统计特征与信任机制的协同推荐》里面的描述"></a>这个方法我是实现自《基于用户人口统计特征与信任机制的协同推荐》里面的描述</h4><h3 id="核心–我的推荐算法的实现："><a href="#核心–我的推荐算法的实现：" class="headerlink" title="核心–我的推荐算法的实现："></a>核心–我的推荐算法的实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def GyJiuShiNB(Similarity_matrix,filename, userId):</span><br><span class="line">    contents = readFile(filename)</span><br><span class="line">    rates = getRatingInfo(contents)</span><br><span class="line">    userDict, itemUser = getUserScoreDataStructure(rates)</span><br><span class="line">    neighbors = getnneighbor(userId, userDict, itemUser)[:10]</span><br><span class="line">    Mo_recommand = &#123;&#125;</span><br><span class="line">    for neighbor_mo in neighbors:</span><br><span class="line">        #相似度前5的邻居</span><br><span class="line">        templ=[]</span><br><span class="line">        MoaMovie = userDict[neighbor_mo[1]]</span><br><span class="line">        MoaMovie.sort(key=lambda x:x[1],reverse=True)</span><br><span class="line">        #把邻居看过5部评分最高的放在MoaMovie</span><br><span class="line">        for i in range(5):</span><br><span class="line">          templ.append(np.argsort(-Similarity_matrix[MoaMovie[i][0]])[i])</span><br><span class="line">        Mo_recommand[neighbor_mo[1]]=templ</span><br><span class="line">        #Mo_recommand 最终格式 [邻居:[相似度最高的5部电影]]</span><br><span class="line">    recommand_list = []</span><br><span class="line">    for key in Mo_recommand:</span><br><span class="line">        recommand_list.append([Mo_recommand[key][random.randint(0,4)], key])</span><br><span class="line">    return [k[0] for k in recommand_list],itemUser, neighbors</span><br></pre></td></tr></table></figure>
<h4 id="通过电影的流派来进行推荐时，可能会出现相同电影的情况，我在最后生成电影列表时加了一个伪随机，范围是M-N。这样不光解决了重复问题，还提高了推荐结果的惊喜度"><a href="#通过电影的流派来进行推荐时，可能会出现相同电影的情况，我在最后生成电影列表时加了一个伪随机，范围是M-N。这样不光解决了重复问题，还提高了推荐结果的惊喜度" class="headerlink" title="通过电影的流派来进行推荐时，可能会出现相同电影的情况，我在最后生成电影列表时加了一个伪随机，范围是M-N。这样不光解决了重复问题，还提高了推荐结果的惊喜度"></a>通过电影的流派来进行推荐时，可能会出现相同电影的情况，我在最后生成电影列表时加了一个伪随机，范围是M-N。这样不光解决了重复问题，还提高了推荐结果的惊喜度</h4><hr>
<h2 id="总体过程就是"><a href="#总体过程就是" class="headerlink" title="总体过程就是"></a>总体过程就是</h2><ul>
<li>先从数据中提取[电影-用户] 这样的数据结构，查找这一部电影都被谁看过</li>
<li>遍历推荐目标之前看过的每一部电影</li>
<li>寻找和推荐目标之前有共同看过的电影的所有用户作为邻居，并求出邻居相似度</li>
<li>找出相似度最高的K个邻居，取出其评分最高的M个电影，再找出与这M部电影相似度最大的N部，然后推荐给用户</li>
<li>如果目标用户从未注册过，即冷启动，那么通过人口普查的方式求得与推荐目标相似度最大的用户，相似度与求电影流派基本相同。</li>
</ul>
<hr>
<h1 id="那到底有啥优点"><a href="#那到底有啥优点" class="headerlink" title="那到底有啥优点"></a>那到底有啥优点</h1><p>原来的协同过滤算法只是单纯的求用户,推荐目标对这个电影的兴趣度就是用户和这个人的相似度，其中夹杂了大量的循环，而也缺少了很多惊喜度和准确度。这个算法从根本上解决了循环时间问题，因为电影和电影之间的相似度是通过电影的本体加上电影的流派来求出其语义相似度，也就是那个大矩阵。在最关键的推荐时，只要按照电影的ID直接拿相似度就出结果。这是时间上。在准确度上，电影在经过本体建模后，其特征已经非常明显，进行求相似就会比单纯的求用户之间的相似度准确的多。比如我爱看天线宝宝，你和我是一样的爱好，就会给你推荐花园宝宝。这样子</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/24/Spark-当启用了一个WordCount的时候，都发生了什么奇妙的事？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/Spark-当启用了一个WordCount的时候，都发生了什么奇妙的事？/" itemprop="url">Spark-当启用了一个WordCount的时候，都发生了什么奇妙的事？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T22:58:00+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="先用一句话搞定WordCount"><a href="#先用一句话搞定WordCount" class="headerlink" title="先用一句话搞定WordCount"></a>先用一句话搞定WordCount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.textFile(&quot;hdfs://haihan:9000/sparkTest/word.txt).flatmap(_.split(&quot; &quot;)).map((_,1)).reduceBykey(_+_).saveAsFile(hdfs://haihan:9000/sparkTest/out)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="在这其中产生的RDD"><a href="#在这其中产生的RDD" class="headerlink" title="在这其中产生的RDD"></a>在这其中产生的RDD</h3><ul>
<li><h3 id="textfile-产生了2个RDD-gt-HadoopRDD和MapPartitionsRDD"><a href="#textfile-产生了2个RDD-gt-HadoopRDD和MapPartitionsRDD" class="headerlink" title="textfile 产生了2个RDD -&gt; HadoopRDD和MapPartitionsRDD"></a>textfile 产生了2个RDD -&gt; HadoopRDD和MapPartitionsRDD</h3></li>
<li><h3 id="flatMap-产生1个RDD-gt-MapPartitionsRDD"><a href="#flatMap-产生1个RDD-gt-MapPartitionsRDD" class="headerlink" title="flatMap 产生1个RDD -&gt; MapPartitionsRDD"></a>flatMap 产生1个RDD -&gt; MapPartitionsRDD</h3></li>
<li><h3 id="map-产生1个RDD-gt-MapPartitionsRDD"><a href="#map-产生1个RDD-gt-MapPartitionsRDD" class="headerlink" title="map 产生1个RDD  -&gt; MapPartitionsRDD"></a>map 产生1个RDD  -&gt; MapPartitionsRDD</h3></li>
<li><h3 id="reduceByKey产生1个RDD-gt-shuffleRDD"><a href="#reduceByKey产生1个RDD-gt-shuffleRDD" class="headerlink" title="reduceByKey产生1个RDD -&gt; shuffleRDD"></a>reduceByKey产生1个RDD -&gt; shuffleRDD</h3></li>
</ul>
<hr>
<h3 id="在这其中Driver和它提交到的集群都发生了什么"><a href="#在这其中Driver和它提交到的集群都发生了什么" class="headerlink" title="在这其中Driver和它提交到的集群都发生了什么"></a>在这其中Driver和它提交到的集群都发生了什么</h3><ul>
<li><h3 id="sc（driver）提交任务并申请资源，master分配资源，worker启动进程Exector（子进程）"><a href="#sc（driver）提交任务并申请资源，master分配资源，worker启动进程Exector（子进程）" class="headerlink" title="sc（driver）提交任务并申请资源，master分配资源，worker启动进程Exector（子进程）"></a>sc（driver）提交任务并申请资源，master分配资源，worker启动进程Exector（子进程）</h3></li>
<li><h3 id="driver向Exector提交计算任务（stage）-driver监控执行进度（如果所有Exector都执行完毕只剩下一个Exector-那样driver会在其他节点再申请一个Exector-看这两个Exector谁快-并用快速执行完的结果）"><a href="#driver向Exector提交计算任务（stage）-driver监控执行进度（如果所有Exector都执行完毕只剩下一个Exector-那样driver会在其他节点再申请一个Exector-看这两个Exector谁快-并用快速执行完的结果）" class="headerlink" title="driver向Exector提交计算任务（stage） driver监控执行进度（如果所有Exector都执行完毕只剩下一个Exector 那样driver会在其他节点再申请一个Exector 看这两个Exector谁快 并用快速执行完的结果）"></a>driver向Exector提交计算任务（stage） driver监控执行进度（如果所有Exector都执行完毕只剩下一个Exector 那样driver会在其他节点再申请一个Exector 看这两个Exector谁快 并用快速执行完的结果）</h3></li>
<li><h3 id="此时worker与master互相心跳感应"><a href="#此时worker与master互相心跳感应" class="headerlink" title="此时worker与master互相心跳感应"></a>此时worker与master互相心跳感应</h3></li>
</ul>
<hr>
<h3 id="Driver是怎么把自己的任务提交到集群里面的"><a href="#Driver是怎么把自己的任务提交到集群里面的" class="headerlink" title="Driver是怎么把自己的任务提交到集群里面的"></a>Driver是怎么把自己的任务提交到集群里面的</h3><ul>
<li><h3 id="第一阶段build-opeartor-DAG：构建RDD，经过一些列操作，形成了一个DAG（有向无环图），Action才会形成DAG"><a href="#第一阶段build-opeartor-DAG：构建RDD，经过一些列操作，形成了一个DAG（有向无环图），Action才会形成DAG" class="headerlink" title="第一阶段build opeartor DAG：构建RDD，经过一些列操作，形成了一个DAG（有向无环图），Action才会形成DAG"></a>第一阶段build opeartor DAG：构建RDD，经过一些列操作，形成了一个DAG（有向无环图），Action才会形成DAG</h3></li>
<li><h3 id="第二阶段提交DAG给DAGScheduler-DAGScheduler负责把DAG图划分一个一个的stage然后再以TaskSet提交，stage本质是Task的一个集合-有几个分区就有几个Task，"><a href="#第二阶段提交DAG给DAGScheduler-DAGScheduler负责把DAG图划分一个一个的stage然后再以TaskSet提交，stage本质是Task的一个集合-有几个分区就有几个Task，" class="headerlink" title="第二阶段提交DAG给DAGScheduler:DAGScheduler负责把DAG图划分一个一个的stage然后再以TaskSet提交，stage本质是Task的一个集合,有几个分区就有几个Task，"></a>第二阶段提交DAG给DAGScheduler:DAGScheduler负责把DAG图划分一个一个的stage然后再以TaskSet提交，stage本质是Task的一个集合,有几个分区就有几个Task，</h3><pre><code>每个Task（pipeline）的操作是一样的并且串行的，只是数据不一样，Task和Task之间是并行的
</code></pre></li>
<li><h3 id="第三阶段TaskScheduler：TaskScheduler在收到上一步的TaskSet后，通过cluster-manager（master）决定在哪个Worker中启动Exector，然后dirver提交Task到Worker中的Exector，通过Work中的Exector来执行。"><a href="#第三阶段TaskScheduler：TaskScheduler在收到上一步的TaskSet后，通过cluster-manager（master）决定在哪个Worker中启动Exector，然后dirver提交Task到Worker中的Exector，通过Work中的Exector来执行。" class="headerlink" title="第三阶段TaskScheduler：TaskScheduler在收到上一步的TaskSet后，通过cluster manager（master）决定在哪个Worker中启动Exector，然后dirver提交Task到Worker中的Exector，通过Work中的Exector来执行。"></a>第三阶段TaskScheduler：TaskScheduler在收到上一步的TaskSet后，通过cluster manager（master）决定在哪个Worker中启动Exector，然后dirver提交Task到Worker中的Exector，通过Work中的Exector来执行。</h3><pre><code>（重试，TaskScheduler在提交Task时遇到问题会启动一个相同的任务来重试）
</code></pre></li>
<li><h3 id="第四阶段Worker：Worker启动线程执行Task-通过BlockManager管理分区。-stage划分：从窄依赖开始，当有宽依赖时就会划分一个stage，如果到最后一步没有其他的宽依赖了，则直接划分成一个Stage，一个Stage中要考虑包含多个前面RDD的计算结果-。"><a href="#第四阶段Worker：Worker启动线程执行Task-通过BlockManager管理分区。-stage划分：从窄依赖开始，当有宽依赖时就会划分一个stage，如果到最后一步没有其他的宽依赖了，则直接划分成一个Stage，一个Stage中要考虑包含多个前面RDD的计算结果-。" class="headerlink" title="第四阶段Worker：Worker启动线程执行Task,通过BlockManager管理分区。(stage划分：从窄依赖开始，当有宽依赖时就会划分一个stage，如果到最后一步没有其他的宽依赖了，则直接划分成一个Stage，一个Stage中要考虑包含多个前面RDD的计算结果)。"></a>第四阶段Worker：Worker启动线程执行Task,通过BlockManager管理分区。(stage划分：从窄依赖开始，当有宽依赖时就会划分一个stage，如果到最后一步没有其他的宽依赖了，则直接划分成一个Stage，一个Stage中要考虑包含多个前面RDD的计算结果)。</h3></li>
</ul>
<hr>
<h2 id="两个重要的概念"><a href="#两个重要的概念" class="headerlink" title="两个重要的概念"></a>两个重要的概念</h2><ul>
<li><h3 id="窄依赖：父（或者多个父）RDD的分区数据全给了一个子RDD-与其他的子RDD无关"><a href="#窄依赖：父（或者多个父）RDD的分区数据全给了一个子RDD-与其他的子RDD无关" class="headerlink" title="窄依赖：父（或者多个父）RDD的分区数据全给了一个子RDD 与其他的子RDD无关"></a>窄依赖：父（或者多个父）RDD的分区数据全给了一个子RDD 与其他的子RDD无关</h3></li>
<li><h3 id="宽依赖：父（或者多个父）RDD的分区数据给了多个子RDD"><a href="#宽依赖：父（或者多个父）RDD的分区数据给了多个子RDD" class="headerlink" title="宽依赖：父（或者多个父）RDD的分区数据给了多个子RDD"></a>宽依赖：父（或者多个父）RDD的分区数据给了多个子RDD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常见的宽依赖:reduceBykey、groupBy、join(特殊情况)</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/24/速度开始Spark之旅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/速度开始Spark之旅/" itemprop="url">速度开始Spark之旅</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T22:00:00+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="安装部署Spark"><a href="#安装部署Spark" class="headerlink" title="安装部署Spark"></a>安装部署Spark</h2><h3 id="下好包后。。。。"><a href="#下好包后。。。。" class="headerlink" title="下好包后。。。。"></a>下好包后。。。。</h3><h3 id="第一步：依旧老办法！tar-zxvf-文件名-C-地址"><a href="#第一步：依旧老办法！tar-zxvf-文件名-C-地址" class="headerlink" title="第一步：依旧老办法！tar -zxvf 文件名 -C 地址"></a>第一步：依旧老办法！tar -zxvf 文件名 -C 地址</h3><h3 id="第二步：apache的软件常规操作，修改配置文件spark-env-sh。这一看就是环境变量了-在文件的末尾加上如下"><a href="#第二步：apache的软件常规操作，修改配置文件spark-env-sh。这一看就是环境变量了-在文件的末尾加上如下" class="headerlink" title="第二步：apache的软件常规操作，修改配置文件spark-env.sh。这一看就是环境变量了.在文件的末尾加上如下"></a>第二步：apache的软件常规操作，修改配置文件spark-env.sh。这一看就是环境变量了.在文件的末尾加上如下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=$&#123;JAVA_HOME&#125;   #JAVA_HOME的地址</span><br><span class="line">export SPARK_MASTER_IP=haihan   #master的地址 如果没配Host 一定要先配Host再直接打名</span><br><span class="line">export SPARK_MASTER_PORT=7077   #端口号</span><br></pre></td></tr></table></figure>
<h3 id="第三步-修改Slave文件-跟hadoop中那个配置datanode地址文件差不多-在该文件中添加子节点所在的位置"><a href="#第三步-修改Slave文件-跟hadoop中那个配置datanode地址文件差不多-在该文件中添加子节点所在的位置" class="headerlink" title="第三步: 修改Slave文件(跟hadoop中那个配置datanode地址文件差不多),在该文件中添加子节点所在的位置"></a>第三步: 修改Slave文件(跟hadoop中那个配置datanode地址文件差不多),在该文件中添加子节点所在的位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gy</span><br><span class="line">clone_gy</span><br></pre></td></tr></table></figure>
<h3 id="第四步-把配置好的Spark目录发送到Worker机器上"><a href="#第四步-把配置好的Spark目录发送到Worker机器上" class="headerlink" title="第四步: 把配置好的Spark目录发送到Worker机器上"></a>第四步: 把配置好的Spark目录发送到Worker机器上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r spark-1.5.2-bin-hadoop2.6/ gy:/home/ghadoop/app</span><br></pre></td></tr></table></figure>
<h3 id="额外的：关于Spark的HA"><a href="#额外的：关于Spark的HA" class="headerlink" title="额外的：关于Spark的HA"></a>额外的：关于Spark的HA</h3><h4 id="配置好zookeeper的情况下，还是在spark-env-sh的文件里增加一条配置"><a href="#配置好zookeeper的情况下，还是在spark-env-sh的文件里增加一条配置" class="headerlink" title="配置好zookeeper的情况下，还是在spark-env.sh的文件里增加一条配置"></a>配置好zookeeper的情况下，还是在spark-env.sh的文件里增加一条配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=zk1:2181,zk2:2181,zk3:2181 -Dspark.deploy.zookeeper.dir=/spark&quot;</span><br></pre></td></tr></table></figure>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明:"></a>使用说明:</h4><ol>
<li>去掉每个节点spark-env.sh配置文件中的Master和端口号的配置 SPARK_MASTER_IP和SPARK_MASTER_PORT</li>
<li>在node1节点上修改slaves配置文件内容指定worker节点</li>
<li>在node1上执行sbin/start-all.sh脚本，然后在node2上执行sbin/start-master.sh启动第二个Master</li>
</ol>
<h2 id="开启Spark之旅"><a href="#开启Spark之旅" class="headerlink" title="开启Spark之旅"></a>开启Spark之旅</h2><h3 id="运行一下官网的蒙特卡罗求π"><a href="#运行一下官网的蒙特卡罗求π" class="headerlink" title="运行一下官网的蒙特卡罗求π"></a>运行一下官网的蒙特卡罗求π</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./spark-1.5.2-bin-hadoop2.6/bin/spark-submit \   #提交jar命令脚本</span><br><span class="line">--class org.apache.spark.examples.SparkPi \      #mian方法</span><br><span class="line">--master spark://haihan:7077 \                   #master地址</span><br><span class="line">--executor-memory 1G \                           #设置内存</span><br><span class="line">--total-executor-cores 2 \                       #设置CPU核数</span><br><span class="line">/app/spark-1.5.2-bin-hadoop2.6/lib/spark-examples-1.5.2-hadoop2.6.0.jar \ #jar包位置</span><br><span class="line">100  #mian方法参数</span><br></pre></td></tr></table></figure>
<h3 id="运行一下shell工具"><a href="#运行一下shell工具" class="headerlink" title="运行一下shell工具"></a>运行一下shell工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./spark-1.5.2-bin-hadoop2.6/bin/spark-shell \</span><br><span class="line">--master spark://haihan:7077 \</span><br><span class="line">--executor-memory 2g \</span><br><span class="line">--total-executor-cores 2</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/24/storm内部通信方式，以及Disruptor到底是个啥/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/storm内部通信方式，以及Disruptor到底是个啥/" itemprop="url">storm内部通信方式，以及Disruptor到底是个啥</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:39:00+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在Storm的世界，"><a href="#在Storm的世界，" class="headerlink" title="在Storm的世界，"></a>在Storm的世界，</h2><h3 id="每个exector都有一个缓存队列"><a href="#每个exector都有一个缓存队列" class="headerlink" title="每个exector都有一个缓存队列"></a>每个exector都有一个缓存队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exector---&gt;nextTuple、execute</span><br></pre></td></tr></table></figure>
<h2 id="每个worker都有一个输入的总管，输出的总管"><a href="#每个worker都有一个输入的总管，输出的总管" class="headerlink" title="每个worker都有一个输入的总管，输出的总管"></a>每个worker都有一个输入的总管，输出的总管</h2><h3 id="总管要位置socker连接"><a href="#总管要位置socker连接" class="headerlink" title="总管要位置socker连接"></a>总管要位置socker连接</h3><h3 id="输入：serverSicjer-ip-port-监听"><a href="#输入：serverSicjer-ip-port-监听" class="headerlink" title="输入：serverSicjer(ip,port)监听"></a>输入：serverSicjer(ip,port)监听</h3><h3 id="输出：Map-lt-ip-port-socket-gt-存入ip地址和端口号，以便找到其他机器的worker"><a href="#输出：Map-lt-ip-port-socket-gt-存入ip地址和端口号，以便找到其他机器的worker" class="headerlink" title="输出：Map&lt;ip+port,socket&gt;存入ip地址和端口号，以便找到其他机器的worker"></a>输出：Map&lt;ip+port,socket&gt;存入ip地址和端口号，以便找到其他机器的worker</h3><h2 id="worker之间内部通信"><a href="#worker之间内部通信" class="headerlink" title="worker之间内部通信"></a>worker之间内部通信</h2><ul>
<li><h3 id="数据从serverscoket传输过来后进行数据分发，把这些数据按照-lt-taskID-inconing队列-gt-的方式存入map中"><a href="#数据从serverscoket传输过来后进行数据分发，把这些数据按照-lt-taskID-inconing队列-gt-的方式存入map中" class="headerlink" title="数据从serverscoket传输过来后进行数据分发，把这些数据按照&lt;taskID,inconing队列&gt;的方式存入map中."></a>数据从serverscoket传输过来后进行数据分发，把这些数据按照&lt;taskID,inconing队列&gt;的方式存入map中.</h3></li>
<li><h3 id="这时bolt中的execute线程通过它自己的队列（Disruptor）在map中取数值到自己的队列，bolt处理后封装Tuple发送（给下游bolt）到一个对外缓冲区中，在缓冲区内里的各个tuple和要发出去的各个task一一对应（tuple1—task14、tuple2—task1-。。）"><a href="#这时bolt中的execute线程通过它自己的队列（Disruptor）在map中取数值到自己的队列，bolt处理后封装Tuple发送（给下游bolt）到一个对外缓冲区中，在缓冲区内里的各个tuple和要发出去的各个task一一对应（tuple1—task14、tuple2—task1-。。）" class="headerlink" title="这时bolt中的execute线程通过它自己的队列（Disruptor）在map中取数值到自己的队列，bolt处理后封装Tuple发送（给下游bolt）到一个对外缓冲区中，在缓冲区内里的各个tuple和要发出去的各个task一一对应（tuple1—task14、tuple2—task1.。。）"></a>这时bolt中的execute线程通过它自己的队列（Disruptor）在map中取数值到自己的队列，bolt处理后封装Tuple发送（给下游bolt）到一个对外缓冲区中，在缓冲区内里的各个tuple和要发出去的各个task一一对应（tuple1—task14、tuple2—task1.。。）</h3></li>
<li><h3 id="最后输出大总管根据这些task信息将这些tuple发送。"><a href="#最后输出大总管根据这些task信息将这些tuple发送。" class="headerlink" title="最后输出大总管根据这些task信息将这些tuple发送。"></a>最后输出大总管根据这些task信息将这些tuple发送。</h3></li>
</ul>
<hr>
<h3 id="Disruptor是一个有界队列，应用场景是生产者消费者模型。它没有锁，就没有竞争，这样速度就很快。所有访问者都记录自己的序号实现方式，并允许多个生产者消费者共享的数据模式。它的底层是一个数组（Ring-Buffer）。"><a href="#Disruptor是一个有界队列，应用场景是生产者消费者模型。它没有锁，就没有竞争，这样速度就很快。所有访问者都记录自己的序号实现方式，并允许多个生产者消费者共享的数据模式。它的底层是一个数组（Ring-Buffer）。" class="headerlink" title="Disruptor是一个有界队列，应用场景是生产者消费者模型。它没有锁，就没有竞争，这样速度就很快。所有访问者都记录自己的序号实现方式，并允许多个生产者消费者共享的数据模式。它的底层是一个数组（Ring Buffer）。"></a>Disruptor是一个有界队列，应用场景是生产者消费者模型。它没有锁，就没有竞争，这样速度就很快。所有访问者都记录自己的序号实现方式，并允许多个生产者消费者共享的数据模式。它的底层是一个数组（Ring Buffer）。</h3><h3 id="生产者生产数据在数组上逐个覆盖"><a href="#生产者生产数据在数组上逐个覆盖" class="headerlink" title="生产者生产数据在数组上逐个覆盖"></a>生产者生产数据在数组上逐个覆盖</h3><h3 id="消费者消费数据在数组上拿取数据"><a href="#消费者消费数据在数组上拿取数据" class="headerlink" title="消费者消费数据在数组上拿取数据"></a>消费者消费数据在数组上拿取数据</h3><h3 id="生产者在生产数据时要判断当前数据是否被消费再进行覆盖"><a href="#生产者在生产数据时要判断当前数据是否被消费再进行覆盖" class="headerlink" title="生产者在生产数据时要判断当前数据是否被消费再进行覆盖"></a>生产者在生产数据时要判断当前数据是否被消费再进行覆盖</h3><h3 id="生产者和消费者在队列之间都有一个序号管理器（Sequence），里面管理生产者或消费者的生产-消费的个数-以及在队列数组中对应的标号"><a href="#生产者和消费者在队列之间都有一个序号管理器（Sequence），里面管理生产者或消费者的生产-消费的个数-以及在队列数组中对应的标号" class="headerlink" title="生产者和消费者在队列之间都有一个序号管理器（Sequence），里面管理生产者或消费者的生产/消费的个数 以及在队列数组中对应的标号"></a>生产者和消费者在队列之间都有一个序号管理器（Sequence），里面管理生产者或消费者的生产/消费的个数 以及在队列数组中对应的标号</h3><h3 id="从而防止了-多个生产者或消费者之间的生产-消费冲突"><a href="#从而防止了-多个生产者或消费者之间的生产-消费冲突" class="headerlink" title="从而防止了 多个生产者或消费者之间的生产/消费冲突"></a>从而防止了 多个生产者或消费者之间的生产/消费冲突</h3><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/24/Storm提交任务的细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/Storm提交任务的细节/" itemprop="url">Storm提交任务的细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T09:17:00+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="——-用户（程序员）——–"><a href="#——-用户（程序员）——–" class="headerlink" title="——-用户（程序员）——–"></a>——-用户（程序员）——–</h2><hr>
<h3 id="1-客户端运行storm-nimbus时，调用storm的脚本，该脚本为每个命令编写一个方法，每个方法生成一条java命令（java-version-xxx-Classname-args）"><a href="#1-客户端运行storm-nimbus时，调用storm的脚本，该脚本为每个命令编写一个方法，每个方法生成一条java命令（java-version-xxx-Classname-args）" class="headerlink" title="1.客户端运行storm nimbus时，调用storm的脚本，该脚本为每个命令编写一个方法，每个方法生成一条java命令（java -version xxx.Classname -args）"></a>1.客户端运行storm nimbus时，调用storm的脚本，该脚本为每个命令编写一个方法，每个方法生成一条java命令（java -version xxx.Classname -args）</h3><hr>
<h2 id="——–nimbus——"><a href="#——–nimbus——" class="headerlink" title="——–nimbus——"></a>——–nimbus——</h2><hr>
<h3 id="2-nimbus启动之后，接受客户端提交任务-在自己写的jar包中主类中的"><a href="#2-nimbus启动之后，接受客户端提交任务-在自己写的jar包中主类中的" class="headerlink" title="2. nimbus启动之后，接受客户端提交任务,在自己写的jar包中主类中的:"></a>2. nimbus启动之后，接受客户端提交任务,在自己写的jar包中主类中的:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StormSubmitter.submitTopology(&quot;GyTopo&quot;, conf, topol);</span><br></pre></td></tr></table></figure>
<h3 id="会启动jar中的main方法，main方法中会执行以下代码"><a href="#会启动jar中的main方法，main方法中会执行以下代码" class="headerlink" title="会启动jar中的main方法，main方法中会执行以下代码"></a>会启动jar中的main方法，main方法中会执行以下代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topologyBuilder.createtopology();</span><br></pre></td></tr></table></figure>
<h5 id="会将程序员写的spout对象和bolt对象进行序列化。客户端会将用户的jar上传到niumbus物理节点-storm-workdir-nimbus-inbox目录下，改名为一个UUID文件名的jar。在nimbus的物理节点的-storm-workdir-nimbus-stormdist目录下，有当前正在运行的topology的jar包和配置文件、序列化对象文件。"><a href="#会将程序员写的spout对象和bolt对象进行序列化。客户端会将用户的jar上传到niumbus物理节点-storm-workdir-nimbus-inbox目录下，改名为一个UUID文件名的jar。在nimbus的物理节点的-storm-workdir-nimbus-stormdist目录下，有当前正在运行的topology的jar包和配置文件、序列化对象文件。" class="headerlink" title="会将程序员写的spout对象和bolt对象进行序列化。客户端会将用户的jar上传到niumbus物理节点 ~/storm/workdir/nimbus/inbox目录下，改名为一个UUID文件名的jar。在nimbus的物理节点的~/storm/workdir/nimbus/stormdist目录下，有当前正在运行的topology的jar包和配置文件、序列化对象文件。"></a>会将程序员写的spout对象和bolt对象进行序列化。客户端会将用户的jar上传到niumbus物理节点 ~/storm/workdir/nimbus/inbox目录下，改名为一个UUID文件名的jar。在nimbus的物理节点的~/storm/workdir/nimbus/stormdist目录下，有当前正在运行的topology的jar包和配置文件、序列化对象文件。</h5><h3 id="3-接受任务后，会将任务进行分配，分配会在产生一个assignment对象，该对象会保存到zookeeper中-storm-assignments，该目录只保存正在运行的Topology任务"><a href="#3-接受任务后，会将任务进行分配，分配会在产生一个assignment对象，该对象会保存到zookeeper中-storm-assignments，该目录只保存正在运行的Topology任务" class="headerlink" title="3. 接受任务后，会将任务进行分配，分配会在产生一个assignment对象，该对象会保存到zookeeper中/storm/assignments，该目录只保存正在运行的Topology任务"></a>3. 接受任务后，会将任务进行分配，分配会在产生一个assignment对象，该对象会保存到zookeeper中/storm/assignments，该目录只保存正在运行的Topology任务</h3><hr>
<h2 id="——-supervisor——"><a href="#——-supervisor——" class="headerlink" title="——-supervisor——-"></a>——-supervisor——-</h2><hr>
<h3 id="4-supervisor通过watch机制，感知到nimbus在zk上的的任务分配信息，从zk上拉取信息，分辨自己任务"><a href="#4-supervisor通过watch机制，感知到nimbus在zk上的的任务分配信息，从zk上拉取信息，分辨自己任务" class="headerlink" title="4. supervisor通过watch机制，感知到nimbus在zk上的的任务分配信息，从zk上拉取信息，分辨自己任务"></a>4. supervisor通过watch机制，感知到nimbus在zk上的的任务分配信息，从zk上拉取信息，分辨自己任务</h3><h3 id="5-supervisor根据自己任务信息，启动自己的worker，并分配一个端口"><a href="#5-supervisor根据自己任务信息，启动自己的worker，并分配一个端口" class="headerlink" title="5.supervisor根据自己任务信息，启动自己的worker，并分配一个端口"></a>5.supervisor根据自己任务信息，启动自己的worker，并分配一个端口</h3><h2 id="———worker——"><a href="#———worker——" class="headerlink" title="———worker——"></a>———worker——</h2><hr>
<h3 id="6-worker启动之后，连接zk。拉取任务"><a href="#6-worker启动之后，连接zk。拉取任务" class="headerlink" title="6.worker启动之后，连接zk。拉取任务"></a>6.worker启动之后，连接zk。拉取任务</h3><h3 id="7-worker根据任务类型，分别执行spout或者blot任务"><a href="#7-worker根据任务类型，分别执行spout或者blot任务" class="headerlink" title="7.worker根据任务类型，分别执行spout或者blot任务"></a>7.worker根据任务类型，分别执行spout或者blot任务</h3><h3 id="spout的生命周期是open、netTuple、outputFiles"><a href="#spout的生命周期是open、netTuple、outputFiles" class="headerlink" title="spout的生命周期是open、netTuple、outputFiles"></a>spout的生命周期是open、netTuple、outputFiles</h3><h3 id="bolt的生命周期是preoars、execute（tuple）、outputfiles"><a href="#bolt的生命周期是preoars、execute（tuple）、outputfiles" class="headerlink" title="bolt的生命周期是preoars、execute（tuple）、outputfiles"></a>bolt的生命周期是preoars、execute（tuple）、outputfiles</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/23/突然发现kafka的几个小细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/突然发现kafka的几个小细节/" itemprop="url">突然发现kafka的几个小细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-23T21:56:00+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-kafka生产数据时的分组策略"><a href="#1-kafka生产数据时的分组策略" class="headerlink" title="1.  kafka生产数据时的分组策略"></a>1.  kafka生产数据时的分组策略</h2><pre><code>默认是defaultPartition Utils.abs(key.hashCode)%numPartitions
key是在发送数据时传入的（proder.send（Keyedmessage（topic，myPartionKey，messAge））），
</code></pre><h2 id="2-kafka如何保证数据的完全生产"><a href="#2-kafka如何保证数据的完全生产" class="headerlink" title="2. kafka如何保证数据的完全生产"></a>2. kafka如何保证数据的完全生产</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ack机制，broker表示发来的数据已确认无误，表示数据已保存内存或磁盘</span><br><span class="line"> 0 不等待block返回确认消息 </span><br><span class="line">-1 等待topic中的某个 partition leader保存成功的状态反馈</span><br><span class="line"> 1 等待topic中的某个 partition 所有副本都保存成功的反馈</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="3-broker如何保存数据"><a href="#3-broker如何保存数据" class="headerlink" title="3. broker如何保存数据"></a>3. broker如何保存数据</h2><h3 id="在理论环境下，-broker-按照顺序读写的机制，可以每秒保存600M的数据（PageCache机制：PageCache本质就是把尽可能多的空闲内存当磁盘缓存来用）当前topic所属的broker上，必定有一个该topic的-partition-，-partition是一个磁盘目录中有多个segment集合（index，log）"><a href="#在理论环境下，-broker-按照顺序读写的机制，可以每秒保存600M的数据（PageCache机制：PageCache本质就是把尽可能多的空闲内存当磁盘缓存来用）当前topic所属的broker上，必定有一个该topic的-partition-，-partition是一个磁盘目录中有多个segment集合（index，log）" class="headerlink" title="在理论环境下， broker 按照顺序读写的机制，可以每秒保存600M的数据（PageCache机制：PageCache本质就是把尽可能多的空闲内存当磁盘缓存来用）当前topic所属的broker上，必定有一个该topic的 partition ， partition是一个磁盘目录中有多个segment集合（index，log）"></a>在理论环境下， broker 按照顺序读写的机制，可以每秒保存600M的数据（PageCache机制：PageCache本质就是把尽可能多的空闲内存当磁盘缓存来用）当前topic所属的broker上，必定有一个该topic的 partition ， partition是一个磁盘目录中有多个segment集合（index，log）</h3><h2 id="4-consumer和partition之间如何做负载均衡"><a href="#4-consumer和partition之间如何做负载均衡" class="headerlink" title="4. consumer和partition之间如何做负载均衡"></a>4. consumer和partition之间如何做负载均衡</h2><p>  ###最好是一一对应， 一个 partition 对应一个 consumer 如果consumer的数量过多，就会产生空闲的consumer<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算法：</span><br><span class="line">有topic1, partitions :p0,p1,p2,p3</span><br><span class="line">加入group中，有如下consumer:c1,c2</span><br><span class="line">首先根据partition索引号对 partitions排序和根据 consumer.id排序</span><br><span class="line">计算倍数：M = [p0,p1,p2,p3].size/[c1,c2].size 结果值</span><br><span class="line">然后依次分配 partitions：c1 = [p0,p1],c2=[p2,p3] 即Ci = [p(i*M),p((i+1)*M-1)]</span><br></pre></td></tr></table></figure></p>
<h2 id="5-如何保证kafka消费者消费数据时全局有序的"><a href="#5-如何保证kafka消费者消费数据时全局有序的" class="headerlink" title="5. 如何保证kafka消费者消费数据时全局有序的"></a>5. 如何保证kafka消费者消费数据时全局有序的</h2><h3 id="保证不了，因为如果要全局有序，必须保证生产有序，存储有序，消费有序。有序，生产做集群，存储分片，消费设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序只有一种可能就是只有一个-生产者-和-一个-partition-一个消费者。这种场景和大数据相悖。"><a href="#保证不了，因为如果要全局有序，必须保证生产有序，存储有序，消费有序。有序，生产做集群，存储分片，消费设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序只有一种可能就是只有一个-生产者-和-一个-partition-一个消费者。这种场景和大数据相悖。" class="headerlink" title="保证不了，因为如果要全局有序，必须保证生产有序，存储有序，消费有序。有序，生产做集群，存储分片，消费设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序只有一种可能就是只有一个 生产者 和 一个 partition , 一个消费者。这种场景和大数据相悖。"></a>保证不了，因为如果要全局有序，必须保证生产有序，存储有序，消费有序。有序，生产做集群，存储分片，消费设置为一个consumerGroup，要保证全局有序，就需要保证每个环节都有序只有一种可能就是只有一个 生产者 和 一个 partition , 一个消费者。这种场景和大数据相悖。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/22/kafka理解和安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/22/kafka理解和安装/" itemprop="url">kafka理解和安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-22T22:39:00+08:00">
                2018-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kafka是一个缓存数据的系统。"><a href="#kafka是一个缓存数据的系统。" class="headerlink" title="kafka是一个缓存数据的系统。"></a>kafka是一个缓存数据的系统。</h1><h2 id="Storm、Sparkstreaming用过消费（获取）kafka的数据进行计算"><a href="#Storm、Sparkstreaming用过消费（获取）kafka的数据进行计算" class="headerlink" title="(Storm、Sparkstreaming用过消费（获取）kafka的数据进行计算)"></a>(Storm、Sparkstreaming用过消费（获取）kafka的数据进行计算)</h2><h3 id="kafka是一个分布式的消息缓存系统。由Scala写成。"><a href="#kafka是一个分布式的消息缓存系统。由Scala写成。" class="headerlink" title="kafka是一个分布式的消息缓存系统。由Scala写成。"></a>kafka是一个分布式的消息缓存系统。由Scala写成。</h3><h3 id="一个生产者消费者模型。类似与JMS的特性"><a href="#一个生产者消费者模型。类似与JMS的特性" class="headerlink" title="一个生产者消费者模型。类似与JMS的特性"></a>一个生产者消费者模型。类似与JMS的特性</h3><hr>
<h1 id="kafka基本理解"><a href="#kafka基本理解" class="headerlink" title="kafka基本理解"></a>kafka基本理解</h1><ol>
<li>类JMS（把点对点和发布订阅模式结合了）消费者可以多个，并且主动拉取数据。</li>
<li>数据生产者messageProducer：只负责数据生产，生产者的代码可以集成到任何系统中。<pre><code>数据分发策略由producer决定。默认是defaultPartition Utils.abs(key.hashCode)%numPartitions
</code></pre></li>
<li><p>数据消费者messageConsumer（增加MessageGroup）：可以有多个。每个consumer消费的数据都是一样的。consumer的组（consumerGroup），可以把多个consumer线程划分一个组，组里面的所有成员共同消费一个topic数据，组员之间不重复消费</p>
</li>
<li><p>数据的分类，主题：topic、destination（消息发送的目的地。本质Queue）<br>topic：目标发送的目的地。这是一个逻辑概念。落到磁盘上是一个partition目录。partition的目录中有多个segment组合（index，log），一个topic对应多个partition。一个partition对应多个segment组合。一个segment默认1G。</p>
<pre><code>每个parttiion可以设置多个副本（参数：--replication-factor 副本数）,所有的读写操作都是通过选举出一个leader来进行的。和mysql有区别，mesql做主从是读写分离。kafka中读写都是leader
</code></pre></li>
<li>broker（中间人）：管理保存数据的进程，只管数据存储，不管是谁生产，是谁消费。在集群中必须有个blockid</li>
<li>数据的分片分组：Partition，有多个，不同机器上有不同的机器的副本。数据生产到集群中的那一个parttion由生产者决定（Key的Hash算法）<br>每个parttiion是一个大文件 切割成小文件存在集群中</li>
</ol>
<p>一个组中的数据最好和分片数对应，一个分片对应一个组中的消费成员<br>如果组中的成员太多，必然会有成员空闲。</p>
<h2 id="partition数量和broker数量关系"><a href="#partition数量和broker数量关系" class="headerlink" title="partition数量和broker数量关系"></a>partition数量和broker数量关系</h2><h3 id="每个parttion数据如何保存到硬盘"><a href="#每个parttion数据如何保存到硬盘" class="headerlink" title="每个parttion数据如何保存到硬盘"></a>每个parttion数据如何保存到硬盘</h3><h3 id="面试题-如何保证消费者消费的数据是有序的"><a href="#面试题-如何保证消费者消费的数据是有序的" class="headerlink" title="面试题:如何保证消费者消费的数据是有序的"></a>面试题:如何保证消费者消费的数据是有序的</h3><ol>
<li>生产者集群模式有序号管理器</li>
<li>blocker端只设置一个partition</li>
<li>consumer如果是一个组，如何保证消费者有序—&gt;消费者线程里自定义一个数据结构来排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个partition的数据是间断性有序的，不连续</span><br><span class="line">针对一个tipic里的数据，只能做到partition内部有序，不能做到全局有序</span><br><span class="line">只有一种情况---&gt; 就是只有一个partition</span><br><span class="line">考虑kafka并发下的负载均衡</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Kafka集群结构"><a href="#Kafka集群结构" class="headerlink" title="Kafka集群结构"></a>Kafka集群结构</h3><ol>
<li>kafka集群的服务器都叫broker。kafka有两类客户端（messageProducer、messageConsumer)</li>
<li>客户端和服务器之间采用TCP服务器连接</li>
<li>kafka中不同的业务的消息通过topic进行区分。而且每一个消息topic都会被分区，以分担消息读写的负载</li>
<li>每一个分区都可以有多个副本，以防止数据的丢失。每一个分区中的数据如果需要更新都必须通过该分区所有副本中的leader来更新！</li>
</ol>
<h3 id="Kafka在消费者中标记信息"><a href="#Kafka在消费者中标记信息" class="headerlink" title="Kafka在消费者中标记信息"></a>Kafka在消费者中标记信息</h3><p>kafka消费者在集群中分组，</p>
<ul>
<li><p>比如两个消费者共同消费一个topic：order_info，A和B所消费的消息不会重复<br>比如 order_inf中有100条消息，每个消息id，编号从0-99 消费者A消费0-49 消费者B就消耗50-99</p>
</li>
<li><p>消费者在具体消费某个topic中的消息时，可以指定起始偏移量</p>
</li>
<li><p>消息的格式可以是javabean、json、xml</p>
</li>
</ul>
<h1 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h1><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><ol>
<li>解压</li>
<li><p>修改server.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">broker.id=1 #注意！根据机器号码来写id编号  从0开始</span><br><span class="line">log.dirs=&#123;日志目录&#125;</span><br><span class="line">zookeeper.connect=weekend05:2181,weekend06:2181,weekend07:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>将zookeeper集群启动</p>
</li>
<li><p>在每一台节点上启动broker<br>bin/kafka-server-start.sh config/server.properties</p>
</li>
<li><p>在kafka集群中创建一个topic<br>bin/kafka-topics.sh –create –zookeeper haihan:2181 –replication-factor 3 –partitions 1 –topic gy_noTopic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper haihan:2181  //zookeeper地址 </span><br><span class="line">--replication-factor 3  //副本数量为3  </span><br><span class="line">--partitions 1          //分区数   </span><br><span class="line">--topic gy_noTopic      //话题名</span><br></pre></td></tr></table></figure>
</li>
<li><p>用一个producer向某一个topic中写入消息 bin/kafka-console-producer.sh –broker-list haihan:9092 –topic gy_noTopic</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list haihan:9092  //broker地址 </span><br><span class="line">--topic gy_noTopic   //话题名</span><br></pre></td></tr></table></figure>
<p>7.用一个comsumer从某一个topic中读取信息<br>bin/kafka-console-consumer.sh –zookeeper haihan:2181 –from-beginning –topic gy_noTopic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper haihan:2181 //zookeeper地址</span><br><span class="line">--from-beginning    //是否显示历史消息</span><br><span class="line">--topic gy_noTopic     //话题名</span><br></pre></td></tr></table></figure>
<p>8.查看一个topic的分区及副本状态信息<br>bin/kafka-topics.sh –describe –zookeeper haihan:2181 –topic order<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper haihan:2181 //zookeeper地址</span><br><span class="line">--topic gy_noTopic      //话题名</span><br></pre></td></tr></table></figure></p>
<h4 id="消息含义-Replicas-副本在集群的broker-id、leader-副本在集群中的leader（通过选举）、Isr-同步状态"><a href="#消息含义-Replicas-副本在集群的broker-id、leader-副本在集群中的leader（通过选举）、Isr-同步状态" class="headerlink" title="消息含义:Replicas 副本在集群的broker.id、leader 副本在集群中的leader（通过选举）、Isr 同步状态"></a>消息含义:Replicas 副本在集群的broker.id、leader 副本在集群中的leader（通过选举）、Isr 同步状态</h4><ol start="9">
<li>查看已创建话题<br>bin/kafka-topics.sh –list –zookeeper haihan:2181</li>
</ol>
<h3 id="面试题警告！"><a href="#面试题警告！" class="headerlink" title="面试题警告！"></a>面试题警告！</h3><h4 id="kafka消费者读操作为什么快"><a href="#kafka消费者读操作为什么快" class="headerlink" title="kafka消费者读操作为什么快"></a>kafka消费者读操作为什么快</h4><p>消费者先从PageCache（内存）中查找，如果发生缺页才进行磁盘查找</p>
<p>最终返回实际数据，PageCache本质就是把尽可能多的空闲内存当磁盘缓存来用。</p>
<p>在JVM中的缓存是当前进行的缓存</p>
<p>使用PageCache功能避免在JVM内存缓存，JVM有强大的GC能力，如果数据进行多次GC后放到持久里就会出现不必要的问题<br>PageCache只是第一步。。进一步Sendfile服务，在硬盘中直接到网卡 不经过应用</p>
<h4 id="总结出来主要原因："><a href="#总结出来主要原因：" class="headerlink" title="总结出来主要原因："></a>总结出来主要原因：</h4><p>1.大量使用内存（PageCache）<br>2.发送数据不走应用（Sendfile）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/20/极速安装Storm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/20/极速安装Storm/" itemprop="url">极速安装Storm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-20T17:00:00+08:00">
                2018-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="重要！！！！-安装storm需要先安装zookeeper"><a href="#重要！！！！-安装storm需要先安装zookeeper" class="headerlink" title="(重要！！！！)安装storm需要先安装zookeeper"></a>(重要！！！！)安装storm需要先安装zookeeper</h2><h3 id="解压后进入conf-gt-修改storm-yaml"><a href="#解压后进入conf-gt-修改storm-yaml" class="headerlink" title="解压后进入conf-&gt;修改storm.yaml"></a>解压后进入conf-&gt;修改storm.yaml</h3><h2 id="必要内容"><a href="#必要内容" class="headerlink" title="必要内容"></a>必要内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#zookeeper的服务节点</span><br><span class="line">storm.zookeeper.servers:</span><br><span class="line">    - &quot;haihan&quot;</span><br><span class="line">    - &quot;gy&quot;</span><br><span class="line">    - &quot;clone_gy&quot;</span><br><span class="line">#nimbus的地址</span><br><span class="line">nimbus.host: &quot;haihan&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="次要内容"><a href="#次要内容" class="headerlink" title="次要内容"></a>次要内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#指定supervisor节点上，启动worker时对应的端口号，每个端口对应槽，每个槽位对应一个worker。</span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">    - 6700</span><br><span class="line">    - 6701</span><br><span class="line">    - 6702</span><br><span class="line">    - 6703</span><br><span class="line">#指定nimbus启动JVM最大可用内存大小</span><br><span class="line">nimbus.childopts: &quot;-Xmx1024m&quot;</span><br><span class="line">#指定supervisor启动JVM最大可用内存大小</span><br><span class="line">supervisor.childopts: &quot;-Xmx1024m&quot;</span><br><span class="line">#指定supervisor节点上，每个worker启动JVM最大可用内存大小</span><br><span class="line">worker.childopts: &quot;-Xmx768m&quot;</span><br><span class="line">#指定ui启动JVM最大可用内存大小，ui服务一般与nimbus同在一个节点上。</span><br><span class="line">ui.childopts: &quot;-Xmx768m&quot;</span><br></pre></td></tr></table></figure>
<h2 id="开始Storm之旅"><a href="#开始Storm之旅" class="headerlink" title="开始Storm之旅"></a>开始Storm之旅</h2><h3 id="启动为后台…master中启动nimbus和ui"><a href="#启动为后台…master中启动nimbus和ui" class="headerlink" title="启动为后台…master中启动nimbus和ui:"></a>启动为后台…master中启动nimbus和ui:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup storm nimbus &amp;</span><br><span class="line">nohup storm ui &amp;</span><br></pre></td></tr></table></figure>
<p>###supervis机器上启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup storm supervisor &amp;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/12/极速上手flume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/极速上手flume/" itemprop="url">极速上手flume</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T14:25:00+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="flume是一个日志采集框架，主要功能收集日志、聚合、传输"><a href="#flume是一个日志采集框架，主要功能收集日志、聚合、传输" class="headerlink" title="flume是一个日志采集框架，主要功能收集日志、聚合、传输"></a>flume是一个日志采集框架，主要功能收集日志、聚合、传输</h3><h3 id="flume可以采集很多形式的源数据、输出到HDFS、HBASE、kafka"><a href="#flume可以采集很多形式的源数据、输出到HDFS、HBASE、kafka" class="headerlink" title="flume可以采集很多形式的源数据、输出到HDFS、HBASE、kafka"></a>flume可以采集很多形式的源数据、输出到HDFS、HBASE、kafka</h3><h2 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h2><h3 id="Agent：flume的一个采集器进程、内部有三个组件：Source、Sink、Channel"><a href="#Agent：flume的一个采集器进程、内部有三个组件：Source、Sink、Channel" class="headerlink" title="Agent：flume的一个采集器进程、内部有三个组件：Source、Sink、Channel"></a>Agent：flume的一个采集器进程、内部有三个组件：Source、Sink、Channel</h3><hr>
<h4 id="Source：和采集源对接，获取数据"><a href="#Source：和采集源对接，获取数据" class="headerlink" title="Source：和采集源对接，获取数据"></a>Source：和采集源对接，获取数据</h4><h4 id="Sink-下沉地。采集数据传输到下一级agent或者最终存储系统"><a href="#Sink-下沉地。采集数据传输到下一级agent或者最终存储系统" class="headerlink" title="Sink:下沉地。采集数据传输到下一级agent或者最终存储系统"></a>Sink:下沉地。采集数据传输到下一级agent或者最终存储系统</h4><h4 id="Channel-Source和sink的传输通道"><a href="#Channel-Source和sink的传输通道" class="headerlink" title="Channel:Source和sink的传输通道"></a>Channel:Source和sink的传输通道</h4><hr>
<h3 id="flume中多个agent可以串联起来一起使用"><a href="#flume中多个agent可以串联起来一起使用" class="headerlink" title="flume中多个agent可以串联起来一起使用"></a>flume中多个agent可以串联起来一起使用</h3><h2 id="开启flume两种基本命令"><a href="#开启flume两种基本命令" class="headerlink" title="开启flume两种基本命令"></a>开启flume两种基本命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./flume-ng agent --conf conf --conf-file ~/apps/flume/conf/netcat-logger.conf -n a1 -Dflume.root.logger=INFO,console </span><br><span class="line"></span><br><span class="line">./flume-ng agent 主要脚本</span><br><span class="line"></span><br><span class="line">--conf conf --conf-file 通过指定配置文件来启动flume</span><br><span class="line"></span><br><span class="line">~/apps/flume/conf/netcat-logger.conf 配置文件位置</span><br><span class="line"></span><br><span class="line">-n a1    指定agent名字</span><br><span class="line"></span><br><span class="line">-Dflume.root.logger=INFO,console 把结果输出到控制台</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flume-ng agent -n $agent的名字 -c conf -f $配置文件地址</span><br></pre></td></tr></table></figure>
<h2 id="一个把目标文件夹里的文件采集到HDFS中的配置文件"><a href="#一个把目标文件夹里的文件采集到HDFS中的配置文件" class="headerlink" title="一个把目标文件夹里的文件采集到HDFS中的配置文件"></a>一个把目标文件夹里的文件采集到HDFS中的配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 定义这个agent中各组件的名字</span><br><span class="line">a1.sources = r1   #获取源数据组件名字</span><br><span class="line">a1.sinks = k1     #下沉输出组件名字</span><br><span class="line">a1.channels = c1  #传输组件名字</span><br><span class="line"></span><br><span class="line"># 描述和配置source组件：r1</span><br><span class="line">a1.sources.r1.type = spooldir   #描述获取源的操作</span><br><span class="line">a1.sources.r1.spoolDir = /home/ghadoop/gyflumes</span><br><span class="line">a1.sources.r1.fileHeader = true</span><br><span class="line"></span><br><span class="line"># 描述和配置sink组件：k1</span><br><span class="line">a1.sinks.k1.channel = c1    #定义传输组件名字</span><br><span class="line">a1.sinks.k1.type = hdfs     #描述下沉的位置</span><br><span class="line">a1.sinks.k1.hdfs.path = hdfs://haihan:9000/gy/%Y-%m-%d/%H    #定义日期和文件</span><br><span class="line">a1.sinks.k1.hdfs.fileType = DataStream</span><br><span class="line">a1.sinks.k1.hdfs.writeFormat=TEXT</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = flumeHdfs   #文件名头部</span><br><span class="line">a1.sinks.k1.hdfs.batchSize = 1000</span><br><span class="line">a1.sinks.k1.hdfs.rollSize = 10240</span><br><span class="line">a1.sinks.k1.hdfs.rollCount = 0</span><br><span class="line">a1.sinks.k1.hdfs.rollInterval = 1</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line"></span><br><span class="line"># 描述和配置channel组件，此处使用是内存缓存的方式</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"># 描述和配置source  channel   sink之间的连接关系</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/11/scala 高级特型和隐式转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="源">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giao哥的档案库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/scala 高级特型和隐式转换/" itemprop="url">scala 高级特型和隐式转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-11T23:22:00+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-高阶函数"><a href="#1-高阶函数" class="headerlink" title="1.高阶函数"></a>1.高阶函数</h2><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val func=(x: Int) =&gt; x*x</span><br><span class="line">arr=Array(1,2,3,4,5)</span><br><span class="line">arr.map(func)</span><br></pre></td></tr></table></figure>
<h4 id="方法也可以作为值传入方法中-此时隐式的将方法转换成了函数"><a href="#方法也可以作为值传入方法中-此时隐式的将方法转换成了函数" class="headerlink" title="方法也可以作为值传入方法中 此时隐式的将方法转换成了函数"></a>方法也可以作为值传入方法中 此时隐式的将方法转换成了函数</h4><h2 id="2-柯里化"><a href="#2-柯里化" class="headerlink" title="2.柯里化"></a>2.柯里化</h2><p>###可以接收多个参数，多个参数在多个括号里</p>
<p>###然后将原来接受两个参数的方法变成新的接受一个参数的方法的过程</p>
<h2 id="3-隐式转换-关键字：-implicit"><a href="#3-隐式转换-关键字：-implicit" class="headerlink" title="3.隐式转换 (关键字： implicit)"></a>3.隐式转换 (关键字： implicit)</h2><ul>
<li>定义在柯里化方法中的implicit修饰的变量</li>
<li>可以引用其他object中implicit修饰的变量</li>
<li>在调用其方法之前    import   里面有implicit修饰的object</li>
<li>含有implicit修饰的object，一定要写在调用其的object前面<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Value&#123;</span><br><span class="line">  implicit val name = &quot;haihan&quot;</span><br><span class="line">&#125;</span><br><span class="line">object implictDemo extends App &#123;</span><br><span class="line">    def say(a: Int)(implicit name: String = &quot;gy&quot;)=&#123;</span><br><span class="line">         println(s&quot;$name   $a&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  import Value.name</span><br><span class="line">  say(13)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-scala的泛型表达方式"><a href="#3-scala的泛型表达方式" class="headerlink" title="3.scala的泛型表达方式"></a>3.scala的泛型表达方式</h2><h3 id="T-lt-上界"><a href="#T-lt-上界" class="headerlink" title="[T &lt;: 上界]"></a>[T &lt;: 上界]</h3><h3 id="T-gt-下界"><a href="#T-gt-下界" class="headerlink" title="[T &gt;: 下界]"></a>[T &gt;: 下界]</h3><h3 id="T-lt-视图定界-它必须传进去一个隐式转换的函数-相当于柯里化中的第二个括号中的隐式函数"><a href="#T-lt-视图定界-它必须传进去一个隐式转换的函数-相当于柯里化中的第二个括号中的隐式函数" class="headerlink" title="[T &lt;% 视图定界] 它必须传进去一个隐式转换的函数,相当于柯里化中的第二个括号中的隐式函数"></a>[T &lt;% 视图定界] 它必须传进去一个隐式转换的函数,相当于柯里化中的第二个括号中的隐式函数</h3><h3 id="T-上下文界定-它必须传一个隐式转换的值-相当于传一个变量-通过变量的类型来进行规则"><a href="#T-上下文界定-它必须传一个隐式转换的值-相当于传一个变量-通过变量的类型来进行规则" class="headerlink" title="[T : 上下文界定] 它必须传一个隐式转换的值,相当于传一个变量 通过变量的类型来进行规则"></a>[T : 上下文界定] 它必须传一个隐式转换的值,相当于传一个变量 通过变量的类型来进行规则</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">源</p>
              <p class="site-description motion-element" itemprop="description">ok！~我立giaogiao</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">源</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
